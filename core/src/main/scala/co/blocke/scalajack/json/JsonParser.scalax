package co.blocke.scalajack.json

import scala.collection._

case class JsonParser() {

  @inline def isDigitChar(char: Char): Boolean =
    '0' <= char && char <= '9'

  @inline def isNumberChar(char: Char): Boolean =
    isDigitChar(char) || (char == '-') || (char == '.') || (char == 'e') || (char == 'E') || (char == '-') || (char == '+')

  def parse(json: String): Any = {

    val chars = json.toCharArray
    var p: Int = 0

    @inline def skipWhitespace() =
      while (p < chars.length && chars(p).isWhitespace) p += 1

    def _parse(): Any =
      chars(p) match {
        case '[' =>
          p += 1
          val arr = mutable.ArrayBuffer[Any]()
          while (p < chars.length && chars(p) != ']') {
            arr.append(_parse())
            if (chars(p) == ',') p += 1 // expect a comma
            skipWhitespace()
          }
          p += 1
          arr.result().toList
        case '{' =>
          p += 1
          val builder = mutable.Map[String, Any]()
          while (p < chars.length && chars(p) != '}') {
            val key = _parse().asInstanceOf[String]
            if (chars(p) == ':') p += 1 // expect a colon
            else throw new Exception("boom")
            builder.put(key, _parse())
            if (chars(p) == ',') p += 1 // expect a comma
            skipWhitespace()
          }
          p += 1
          builder.toMap
        case '"' =>
          p += 1
          val mark = p
          while (p < chars.length && chars(p) != '"')
            p += 1
          val s = json.substring(mark, p)
          p += 1
          s
        case 't' =>
          p += 4
          true
        case 'f' =>
          p += 5
          false
        case 'n' =>
          p += 4
          null
        case d if isNumberChar(d) =>
          val mark = p
          while (p < chars.length && isNumberChar(chars(p)))
            p += 1
          BigDecimal(json.substring(mark, p))
      }

    _parse()

  }

}
